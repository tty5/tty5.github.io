# tcp连接状态图

![tcp-stat.png](/image/tcp-stat.png)

客户端关闭连接的时候, 需要服务端把这个连接的内容读到EOF的时候, 客户端才会关闭


# tcp echo
## tcp 服务端建立过程

先申请一个socket ```socket(AF_INET, SOCK_STREAM, 0);```

和一个地址绑定 ```bind(server_fd, (struct sockaddr *) &server, sizeof(server));```

监听这个socket ```listen(server_fd, 128);```

accept请求 ```accept(server_fd, (struct sockaddr *) &client, &client_len);```

对client进行读写

```
server_fd = socket(AF_INET, SOCK_STREAM, 0);
bind(server_fd, (struct sockaddr *) &server, sizeof(server));
err = listen(server_fd, 128);
client_fd = accept(server_fd, (struct sockaddr *) &client, &client_len);
read = recv(client_fd, buf, BUFFER_SIZE, 0);
err = send(client_fd, buf, read, 0);
```

# 客户端代码

```
sockfd = socket(AF_INET, SOCK_STREAM, 0);
connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr));
write(sockfd, sendline, strlen(sendline))
```

# tcp的读写调用原理

几个重要的结论：

1. read总是在接收缓冲区有数据时立即返回，而不是等到给定的read buffer填满时返回。

只有当receive buffer为空时，blocking模式才会等待，而nonblock模式下会立即返回-1（errno = EAGAIN或EWOULDBLOCK）

2. blocking的write只有在缓冲区足以放下整个buffer时才返回（与blocking read并不相同）

nonblock write则是返回能够放下的字节数，之后调用则返回-1（errno = EAGAIN或EWOULDBLOCK）

# 系统查看方式

所有的sock文件都是在某个进程下的fd
```
lsof -a -i -p pid  -P
-a 与关系
-i 网络
-p 进程号
-P 显示原始端口号, 而不是名字
xxx TCP *:8080 (LISTEN)
xxx localhost:8080->localhost:33000 (ESTABLISHED)
```

unix sock也是一个socket, 只是拿本地路径替代端口, 在ll /proc/pid/fd/目录下, 都是socket文件

lsof 4.89才能显示unix socket的另一端, kernel 3.3以上
```
rpm -Uvh https://mirrors.aliyun.com/fedora/releases/28/Everything/x86_64/os/Packages/l/lsof-4.89-8.fc28.x86_64.rpm
lsof -E -aU  -p pid
-U 显示unix socket
-E 显示另一端的endpoint, +E把对应的进程也显示出来
COMMAND    PID USER   FD   TYPE  SIZE/OFF     NODE NAME
x20     209409 root    3u  unix       0t0 44213827 /run/123.sock type=STREAM
x20     209409 root    4u  unix       0t0 44218819 /run/123.sock type=STREAM ->INO=44235265 210521,curl,3u
curl    210521 root    3u  unix       0t0 44235265 type=STREAM ->INO=44218819 209409,x20,4u

```
