---
categories: linux-cmd
---

# pkill killall
```
平时都是kill pid, 有时候挺麻烦的, 虽然也知道killall, pkill命令的存在, 但是总有不确定的感觉, 比如killall a, 会不会把aa kill掉, /usr/bin/a能不能一起kill掉

下面是总结

killall是忽略启动路径, 只匹配可执行文件名, 所以a和/usr/bin/a会一起kill掉
killall可执行文件名需要全等, killall a不会kill aa, 需要正则的时候就使用-r, 默认信号是SIGTERM

pkill的功能就强大很多, 可以根据各种不同的条件来kill
-g Only match processes in the process group IDs listed
-f 带上参数一起
-n 所有进程的最新
-o 最旧
-P 父进程是多少
-s session id来匹配
-t terminal来匹配
其他看man


```

# pgrep 用来找指定命令的进程

**pgrep不匹配全名, pkill匹配全名**

pgrep perf 默认只显示pid, -l显示命令 -a显示命令行全信息

还有一些其他的条件, groupid, tty, parent, 看man

```
-g Only match processes in the process group IDs listed
-f 带上参数一起
-n 所有进程的最新
-o 最旧
-P 父进程是多少
-s session id来匹配
-t terminal来匹配
其他看man
```


# vm starttime

```
date -d "`cut -f1 -d. /proc/uptime` seconds ago"
ps -eo pid,lstart,cmd |grep container
```


# 开机时间

```last -x |grep run```可以历史系统运行的时间段

```last -10```显示的是用户登录历史



# dir compare 需要比较文件夹里面的文件是不是一样
```
其实就是把所有文件排序以后, cat到一起计算, 有时候上下文件叠换, 会有问题, 勉强可以使用
find tmp/ |sort  -u |xargs cat |md5sum
```


# strace
strace 只是strace主线程, 需要子线程的话, 需要strace -f

# time时间
## date 显示指定时间戳时间

```
date -d @1551773019
Tue Mar  5 16:03:39 CST 2019
```

## ntp 同步时间
```
ntpdate  ntp1.aliyun.com
```

## 时区
```
rm -f /etc/localtime
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
```

# tty
## console tty 区别
tty teletypewriter, linux里面有输入, 输出的设备, 现在基本都是虚拟设备, pts之类的

console, 特殊的tty, 可以显示系统日志的, 比如刚开机

## 获取当前tty
```
tty
/dev/pts/15
```
## 检查是否是一个tty
```
tty -s
echo $?
```

## dump tty info
```
$stty -a
speed 38400 baud; rows 65; columns 231; line = 0;
```


# gzip gunzip

```
gzip [file-name]

强制gzip不能删除原文件
gzip -k [file-name]

gzip列表详细信息与压缩文件相关
gzip -l [compressed-file-name]

没有文件名, stdin读取, stdout输出
cat filename |gzip > filename

```

# gunzip
和gzip功能相反, 其他都一样


# tty auto login
 
/usr/lib/systemd/system/serial-getty@.service
 
add -a root

# qemu launch cmd

```qemu-system-x86_64-lite -nographic  -serial mon:stdio -smp 4 -m 8000 -drive file=xcentos.qcow2,if=virtio   -kernel vmlinux -append "root=/dev/vda1 console=ttyS0" -gdb tcp::5 -redir tcp:15::22```

```qemu-system-x86_64 -enable-kvm -nographic -serial mon:stdio -smp 4 -m 8000 -drive file=xcentos.qcow2,if=virtio   -kernel arch/x86/boot/bzImage -append "root=/dev/vda1 console=ttyS0"```



# 换系统目录启动 chroot

```
mkdir /mnt/abc
mount /dev/sda3 /mnt/abc
mkdir /mnt/abc/dev
mkdir /mnt/abc/proc
mkdir /mnt/abc/sys
mount --bind /dev /mnt/abc/dev
mount --bind /proc /mnt/abc/proc
mount --bind /sys /mnt/abc/sys
chroot /mnt/abc
grub-install /dev/sda

```


# ssh connect
## 修改服务器端参数

在其中添加一行内容,意思是向客户端每60秒发一次保持连接的信号

ClientAliveInterval  60

如果仍要设置断开时间,还有一个参数可以添加

ClientAliveCountMax  60

意思是如果客户端60次未响应就断开连接,依据你期望的时间来设定

## 修改本地参数

也可以让客户端向服务器发送保持连接信号,路径是/etc/ssh/ssh_config

在其中类似的添加相应的参数也行

ServerAliveInterval  5

ServerAliveCountMax  3

# fio
## 延迟测试
fio -filename=10g -direct=1 -iodepth 1 -rw=randwrite -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g

fio -filename=10g -direct=1 -iodepth 1 -rw=randread -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g

## 带宽测试
fio -filename=10g -direct=1 -iodepth 128 -rw=read -ioengine=libaio -bs=1024k -numjobs=1 -runtime=10 -name=x -size=10g

fio -filename=10g -direct=1 -iodepth 128 -rw=write -ioengine=libaio -bs=1024k -numjobs=1 -runtime=10 -name=x -size=10g

## iops测试
fio -filename=10g -direct=1 -iodepth 128 -rw=randwrite -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g

fio -filename=10g -direct=1 -iodepth 128 -rw=randread -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g


# vim indent
set autoindent，即每行的缩进值与上一行相等，使用 set noautoindent 可以取消设置

当你在输入状态用回车键插入一个新行，或者在 normal 状态用 o 或者 O 插入一个新行时，autoindent 会自动地将当前行的缩进拷贝到新行，也就是"自动对齐”

set cindent，它会按照 C 语言的语法，自动地调整缩进的长度，比如，当你输入了半条语句然后回车时，缩进会自动增加一个 TABSTOP 值，当你键入了一个右花括号时，会自动减少一个 TABSTOP 值。

set smartindent，在这种缩进模式中，每一行都和前一行有相同的缩进量，同时这种缩进形式能正确的识别出花括号，当遇到右花括号（}），则取消缩进形式。此外还增加了识别C语言关键字的功能。如果一行是以#开头的，那么这种格式将会被特殊对待而不采用缩进格式。

tabstop=8 tab显示长度为8

set shiftwidth=8 一级缩进为8

set noexpandtab 保留tab

set nocompatible 不是vi模式 可以使用backspace

# mi route
```
/etc/samba/smb.conf.template

interfaces = br-lan eth0
```

```
/etc/config/firewall

config rule 'ssh_tcp'
        option src 'wan'
        option dest_port '22 80 139 389 445 901'
        option proto 'tcp'
        option target 'ACCEPT'
        option name 'ssh incoming tcp'
```

# centos 安装 proxychains

```rpm -Uvh https://mirrors.aliyun.com/fedora/releases/27/Everything/x86_64/os/Packages/p/proxychains-ng-4.11-4.fc27.x86_64.rpm```

# chrome

```
cd /ect/yum.repos.d/
vim google-chrome.repo

[google-chrome]
name=google-chrome
baseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearch
enabled=0
gpgcheck=1
gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub

yum --enablerepo google-chrome -y install google-chrome-stable
```

## root 界面启动
```
vim /usr/bin/google-chrome
最后加上 "--no-sandbox"
```
