---
categories: linux-cmd
---

# pkill killall
```
平时都是kill pid, 有时候挺麻烦的, 虽然也知道killall, pkill命令的存在, 但是总有不确定的感觉, 比如killall a, 会不会把aa kill掉, /usr/bin/a能不能一起kill掉

下面是总结

killall是忽略启动路径, 只匹配可执行文件名, 所以a和/usr/bin/a会一起kill掉
killall可执行文件名需要全等, killall a不会kill aa, 需要正则的时候就使用-r, 默认信号是SIGTERM

pkill的功能就强大很多, 可以根据各种不同的条件来kill
-g Only match processes in the process group IDs listed
-f 带上参数一起
-n 所有进程的最新
-o 最旧
-P 父进程是多少
-s session id来匹配
-t terminal来匹配
其他看man


```

# pgrep 用来找指定命令的进程

**pgrep不匹配全名, pkill匹配全名**

pgrep perf 默认只显示pid, -l显示命令 -a显示命令行全信息

还有一些其他的条件, groupid, tty, parent, 看man

```
-g Only match processes in the process group IDs listed
-f 带上参数一起
-n 所有进程的最新
-o 最旧
-P 父进程是多少
-s session id来匹配
-t terminal来匹配
其他看man
```


# vm starttime

```
date -d "`cut -f1 -d. /proc/uptime` seconds ago"
ps -eo pid,lstart,cmd |grep container
```


# 开机时间

```last -x |grep run```可以历史系统运行的时间段

```last -10```显示的是用户登录历史



# dir compare 需要比较文件夹里面的文件是不是一样
```
其实就是把所有文件排序以后, cat到一起计算, 有时候上下文件叠换, 会有问题, 勉强可以使用
find tmp/ |sort  -u |xargs cat |md5sum
```


# strace
strace 只是strace主线程, 需要子线程的话, 需要strace -f

# time时间
## date 显示指定时间戳时间

```
date -d @1551773019
Tue Mar  5 16:03:39 CST 2019
```

## ntp 同步时间
```
ntpdate  ntp1.aliyun.com
```

## 时区
```
rm -f /etc/localtime
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
```

# tty
## console tty 区别
tty teletypewriter, linux里面有输入, 输出的设备, 现在基本都是虚拟设备, pts之类的

console, 特殊的tty, 可以显示系统日志的, 比如刚开机

## 获取当前tty
```
tty
/dev/pts/15
```
## 检查是否是一个tty
```
tty -s
echo $?
```

## dump tty info
```
$stty -a
speed 38400 baud; rows 65; columns 231; line = 0;
```


# gzip gunzip

```
gzip [file-name]

强制gzip不能删除原文件
gzip -k [file-name]

gzip列表详细信息与压缩文件相关
gzip -l [compressed-file-name]

没有文件名, stdin读取, stdout输出
cat filename |gzip > filename

```

# gunzip
和gzip功能相反, 其他都一样


# tty auto login
 
/usr/lib/systemd/system/serial-getty@.service
 
add -a root

# qemu launch cmd

```qemu-system-x86_64-lite -nographic  -serial mon:stdio -smp 4 -m 8000 -drive file=xcentos.qcow2,if=virtio   -kernel vmlinux -append "root=/dev/vda1 console=ttyS0" -gdb tcp::5 -redir tcp:15::22```

```qemu-system-x86_64 -enable-kvm -nographic -serial mon:stdio -smp 4 -m 8000 -drive file=xcentos.qcow2,if=virtio   -kernel arch/x86/boot/bzImage -append "root=/dev/vda1 console=ttyS0"```



# 换系统目录启动 chroot

```
mkdir /mnt/abc
mount /dev/sda3 /mnt/abc
mkdir /mnt/abc/dev
mkdir /mnt/abc/proc
mkdir /mnt/abc/sys
mount --bind /dev /mnt/abc/dev
mount --bind /proc /mnt/abc/proc
mount --bind /sys /mnt/abc/sys
chroot /mnt/abc
grub-install /dev/sda

```


# ssh connect
## 修改服务器端参数

在其中添加一行内容,意思是向客户端每60秒发一次保持连接的信号

ClientAliveInterval  60

如果仍要设置断开时间,还有一个参数可以添加

ClientAliveCountMax  60

意思是如果客户端60次未响应就断开连接,依据你期望的时间来设定

## 修改本地参数

也可以让客户端向服务器发送保持连接信号,路径是/etc/ssh/ssh_config

在其中类似的添加相应的参数也行

ServerAliveInterval  5

ServerAliveCountMax  3

## ssh auto discon
ssh -o ServerAliveInterval=3 -o ServerAliveCountMax=3 -o StrictHostKeyChecking=no

# fio
## 延迟测试
fio -filename=10g -direct=1 -iodepth 1 -rw=randwrite -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g

fio -filename=10g -direct=1 -iodepth 1 -rw=randread -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g

## 带宽测试
fio -filename=10g -direct=1 -iodepth 128 -rw=read -ioengine=libaio -bs=1024k -numjobs=1 -runtime=10 -name=x -size=10g

fio -filename=10g -direct=1 -iodepth 128 -rw=write -ioengine=libaio -bs=1024k -numjobs=1 -runtime=10 -name=x -size=10g

## iops测试
fio -filename=10g -direct=1 -iodepth 128 -rw=randwrite -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g

fio -filename=10g -direct=1 -iodepth 128 -rw=randread -ioengine=libaio -bs=4k -numjobs=1 -runtime=10 -name=x -size=10g


# vim indent
set autoindent，即每行的缩进值与上一行相等，使用 set noautoindent 可以取消设置

当你在输入状态用回车键插入一个新行，或者在 normal 状态用 o 或者 O 插入一个新行时，autoindent 会自动地将当前行的缩进拷贝到新行，也就是"自动对齐”

set cindent，它会按照 C 语言的语法，自动地调整缩进的长度，比如，当你输入了半条语句然后回车时，缩进会自动增加一个 TABSTOP 值，当你键入了一个右花括号时，会自动减少一个 TABSTOP 值。

set smartindent，在这种缩进模式中，每一行都和前一行有相同的缩进量，同时这种缩进形式能正确的识别出花括号，当遇到右花括号（}），则取消缩进形式。此外还增加了识别C语言关键字的功能。如果一行是以#开头的，那么这种格式将会被特殊对待而不采用缩进格式。

tabstop=8 tab显示长度为8

set shiftwidth=8 一级缩进为8

set noexpandtab 保留tab

set nocompatible 不是vi模式 可以使用backspace

# mi route
```
/etc/samba/smb.conf.template

interfaces = br-lan eth0
```

```
/etc/config/firewall

config rule 'ssh_tcp'
        option src 'wan'
        option dest_port '22 80 139 389 445 901'
        option proto 'tcp'
        option target 'ACCEPT'
        option name 'ssh incoming tcp'
```

# centos 安装 proxychains

```rpm -Uvh https://mirrors.aliyun.com/fedora/releases/27/Everything/x86_64/os/Packages/p/proxychains-ng-4.11-4.fc27.x86_64.rpm```

# chrome

```
cd /ect/yum.repos.d/
vim google-chrome.repo

[google-chrome]
name=google-chrome
baseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearch
enabled=0
gpgcheck=1
gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub

yum --enablerepo google-chrome -y install google-chrome-stable
```

## root 界面启动
```
vim /usr/bin/google-chrome
最后加上 "--no-sandbox"
```

# top
一般情况下
```
-p 单独某个pid, 2个进程就是 -p p1,p2
-c 显示整个命令行
-H 线程模式
-d 刷新时间, 很少用

交互命令
s 改变刷新时间
H 改变线程模式
f 增加显示项目

l 切换显示平均负载和启动时间信息。 
m 切换显示内存信息。 
t 切换显示进程和CPU状态信息。 
c 切换显示命令名称和完整命令行。 

M 根据驻留内存大小进行排序。 
P 根据CPU使用百分比大小进行排序。 
T 根据时间/累计时间进行排序。 

W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法
```

# pidstat

查看一个进程的状态, pidstat, 可以查看sys占用率

```
pidstat -ul -p 40925 1

-C 指定进程名, 不运行的是不打印出来的, 需要-p ALL来指定, 指定了-p, 都会打印出来
-p 指定pid
-r 内存
-d disk
-u cpu
-t 把每个task都打印出来
```

# fstab
```
LABEL=/    /    ext3    defaults    1    1
/dev/sda2    /mnt/D/    vfat    defaults    0    0
/proc /chroot/mysql/proc none defaults,bind 0 0

bind使用方式
findmnt [/]是bind mount

第一列：设备名或者设备卷标名 (/dev/sda10 或者 LABEL=/)
第二列: 设备挂载目录 (例如上面的 "/" 或者 "/mnt/D/")
第三列: 设备文件系统 (例如上面的 "ext3" 或者 "vfat")
第四列：挂载参数 (看帮助 man 8 mount)
    对于已经挂载好的设备，例如上面的/dev/sda2，现在要改变挂载参数，这时可以不用卸载该设备，
而可以使用下面的命令（没有挂载的设备，remount 这个参数无效）
    #mount /mnt/D/ -o remount,ro （改defaults为ro）
    为了安全起见，可以指明其他挂载参数，例如：
    noexec (不允许可执行文件可执行，但千万不要把根分区挂为noexec，那就无法使用系统了，
            连mount 命令都无法使用了，这时只有重新做系统了！)
    nodev (不允许挂载设备文件)
    nosuid,nosgid(不允许有 suid 和 sgid 属性)
    nouser(不允许普通用户挂载)
第五列：指明是否要备份 (0 为不备份，1 为要备份, 一般根分区要备份)
第六列：指明自检顺序 (0 为不自检，1 或者 2 为要自检, 如果是根分区要设为1，其他分区只能是2)
```

# cut
```
主要参数
-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c ：以字符为单位进行分割。
-d ：自定义分隔符，默认为制表符。
-f  ：与-d一起使用，指定显示哪个区域。
-n ：取消分割多字节字符。仅和 -b 标志一起使用

提取每一行的第3个字节
who|cut -b 3
who|cut -b 1-200
who|cut -c 3-5,8
who|cut -d ' ' -f 1
```


# rinetd port 配置
```
docker run -it  --network host fedora bash

dnf install -y bash-completion which rinetd vim procps-ng -y
exec bash
vim /etc/rinetd.conf
rinetd
ctrl p q
```

# redsocks
```
docker run --name redsocks -d --network host ubuntu sleep 999999999
docker exec -it redsocks bash

sed -i s@archive.ubuntu.com@mirrors.163.com@g /etc/apt/sources.list
sed -i s@security.ubuntu.com@mirrors.163.com@g /etc/apt/sources.list
apt update
apt install bash-completion vim redsocks -y
source  /etc/bash_completion

vim /etc/redsocks.conf

redsocks
```

## iptable
```
iptables -t nat -N REDSOCKS
iptables -t nat --flush REDSOCKS
iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN
iptables -t nat -A REDSOCKS -d 11.0.0.0/8 -j RETURN
iptables -t nat -A REDSOCKS -d 30.0.0.0/8 -j RETURN
iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN
iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN
iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN
iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN
iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN
iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN
iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345
```
# centos 安装中文字体

```yum install -y *chinese-fonts*```

# ubuntu
## ubuntu mirror
```
sed -i s@archive.ubuntu.com@mirrors.163.com@g /etc/apt/sources.list
sed -i s@security.ubuntu.com@mirrors.163.com@g /etc/apt/sources.list
apt update
apt install bash-completion vim -y
source  /etc/bash_completion
```

## key
```
bind '"\e[1;5D" backward-word' 
bind '"\e[1;5C" forward-word'
```

# net 网络流量查看命令

nethogs: 按进程查看流量占用

iptraf: 按连接/端口查看流量

dstat -n: 按设备查看流量

ethtool: 诊断工具

tcpdump: 抓包工具

ss: 连接查看工具

其他: dstat, slurm, nload, bmon

# tmux

## 交换pane
```
bind-key    -T prefix {                swap-pane -U
bind-key    -T prefix }                swap-pane -D
```
